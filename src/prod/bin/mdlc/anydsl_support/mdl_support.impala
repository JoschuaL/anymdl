type float4 = [float*4];

type float3 = [float*3];

type float2 = [float*2];

type double4 = [double*4];

type double3 = [double*3];

type double2 = [double*2];

type int4 = [int*4];

type int3 = [int*3];

type int2 = [int*2];

type bool4 = [bool*4];

type bool3 = [bool*3];

type bool2 = [bool*2];


type float2x2 = [float2*2];

type float3x2 = [float2*3];

type float4x2 = [float2*4];

type float2x3 = [float3*2];

type float3x3 = [float3*3];

type float4x3 = [float3*4];

type float2x4 = [float4*2];

type float3x4 = [float4*3];

type float4x4 = [float4*4];


type double2x2 = [double2*2];

type double3x2 = [double2*3];

type double4x2 = [double2*4];

type double2x3 = [double3*2];

type double3x3 = [double3*3];

type double4x3 = [double3*4];

type double2x4 = [double4*2];

type double3x4 = [double4*3];

type double4x4 = [double4*4];

type color = [float*3];


struct material {
    thin_walled: bool,
    surface: compiled_material_surface,
    backface: compiled_material_surface,
    ior: color,
    volume: compiled_material_volume,
    geometry: material_geometry,
}


fn @material__bool_material_surface_material_surface_color_material_volume_material_geometry_mdl_math(
    thin_walled: fn(State) -> bool,
    surface: fn(State) -> material_surface,
    backface: fn(State) -> material_surface,
    ior: fn(State) -> color,
    volume: fn(State) -> material_volume,
    geometry: fn(State) -> material_geometry,
    math: mdl_math
) -> material {
    let geo: material_geometry = geometry(dummy_state);
    material{
        thin_walled: thin_walled(dummy_state),
        surface: surface(dummy_state)(geo),
        backface: backface(dummy_state)(geo),
        ior: ior(dummy_state),
        volume: volume(dummy_state)(geo),
        geometry: geo,
    }
}

fn @material__material(copy: fn(State) -> material) -> material{
    copy(dummy_state)
}

type material_surface = fn(material_geometry) -> compiled_material_surface;

struct compiled_material_surface {
    scattering: executable_bsdf,
    emission: compiled_material_emission,
};

fn @material_surface__bsdf_material_emission_mdl_math(
    scattering: fn(State) -> bsdf,
    emission: fn(State) -> material_emission,
    math: mdl_math
) -> material_surface{
    |geo:material_geometry|{
        compiled_material_surface{
            scattering: scattering(dummy_state)(geo),
            emission: emission(dummy_state)(geo)
        }
    }
}


fn @material_surface__material_surface(copy: fn(State) -> material_surface) -> material_surface{
    copy(dummy_state)
}

type material_emission = fn(material_geometry) -> compiled_material_emission;

struct compiled_material_emission {
    emission: executable_edf,
    intensity: fn(State) -> color,
    mode: intensity_mode
};
fn @material_emission__edf_color_intensity_mode_mdl_math(
    emission: fn(State) -> edf, 
    intensity: fn(State) -> color, 
    mode: fn(State) -> intensity_mode,
    math: mdl_math
) -> material_emission{
    |geo:material_geometry|{
        compiled_material_emission{
            emission: emission(dummy_state)(geo),
            intensity: intensity,
            mode: mode(dummy_state)
        }
    }
}

enum intensity_mode {
    intensity_radiant_exitance,
    intensity_power
}

type material_volume = fn(material_geometry) -> compiled_material_volume;

struct compiled_material_volume {
    scattering: executable_vdf,
    absorption_coefficient: fn(State) -> color,
    scattering_coefficient: fn(State) -> color
}

fn @material_volume__vdf_color_color_mdl_math(
    scattering: fn(State) -> vdf,
    absorption_coefficient: fn(State) -> color,
    scattering_coefficient: fn(State) -> color,
    math: mdl_math
) -> material_volume 
{
    |geo:material_geometry|{
        compiled_material_volume{
            scattering: scattering(dummy_state)(geo),
            absorption_coefficient: absorption_coefficient,
            scattering_coefficient: scattering_coefficient
        }
    }
}

struct material_geometry {
    displacement: fn(State) -> float3,
    cutout_opacity: fn(State) -> float,
    normal: fn(State) -> float3
}

fn @material_geometry__float3_float_float3_mdl_math(
    displacement: fn(State) -> float3,
    cutout_opacity: fn(State) -> float,
    normal: fn(State) -> float3,
    math: mdl_math
) -> material_geometry
{
    material_geometry{
        displacement: displacement,
        cutout_opacity: cutout_opacity,
        normal: normal
    }
}



    static BSDF_EVENT_DIFFUSE      = 1;
    static BSDF_EVENT_GLOSSY       = 1 << 1;
    static BSDF_EVENT_SPECULAR	    = 1 << 2;
    static BSDF_EVENT_REFLECTION   = 1 << 3;
    static BSDF_EVENT_TRANSMISSION = 1 << 4;



    static BSDF_EVENT_ABSORB = 0;
    static BSDF_EVENT_DIFFUSE_REFLECTION    = BSDF_EVENT_DIFFUSE  | BSDF_EVENT_REFLECTION;
    static BSDF_EVENT_DIFFUSE_TRANSMISSION  = BSDF_EVENT_DIFFUSE  | BSDF_EVENT_TRANSMISSION;
    static BSDF_EVENT_GLOSSY_REFLECTION     = BSDF_EVENT_GLOSSY   | BSDF_EVENT_REFLECTION;
    static BSDF_EVENT_GLOSSY_TRANSMISSION   = BSDF_EVENT_GLOSSY   | BSDF_EVENT_TRANSMISSION;
    static BSDF_EVENT_SPECULAR_REFLECTION   = BSDF_EVENT_SPECULAR | BSDF_EVENT_REFLECTION;
    static BSDF_EVENT_SPECULAR_TRANSMISSION = BSDF_EVENT_SPECULAR | BSDF_EVENT_TRANSMISSION;

   




static BSDF_USE_MATERIAL_IOR: float = -1.0f;

struct BSDF_sample_data
{
    // Input fields
    ior1: float3, // IOR current medium
    ior2: float3, // IOR other side
    k1: float3,  // outgoing direction
    xi: float3,  // pseudo-random sample number

    // Output fields
    k2: float3,            // incoming direction
    pdf: float,           // pdf (non-projected hemisphere)
    bsdf_over_pdf: float3, // bsdf * dot(normal, k2) / pdf
    event_type: int       // BSDF_event_type
}

struct BSDF_pdf_data
{
    // Input fields
    ior1: float3,
    ior2: float3,
    k1: float3,
    k2: float3,

    // Output fields
    pdf: float,
}

struct BSDF_evaluate_data
{
    // Input fields
    ior1: float3,
    ior2: float3,
    k1: float3,
    k2: float3,

    // Output fields
    bsdf: float3,
    pdf: float,
}


    static EDF_EVENT_NONE = 0;
    static EDF_EVENT_EMISSION = 1;


struct EDF_sample_data
{
    // Input fields
    xi: float3,              // pseudo-random sample number

    // Output fields
    k1: float3,              // outgoing direction
    pdf: float,              // pdf (non-projected hemisphere)
    edf_over_pdf: float3,    // edf * dot(normal,k1) / pdf
    event_type: int
}

struct EDF_pdf_data
{
    // Input fields
    k1: float3,              // outgoing direction

    // Output fields
    pdf: float              // pdf (non-projected hemisphere)
}

struct EDF_evaluate_data
{
    // Input fields
    k1: float3,              // outgoing direction

    // Output fields
    cos: float,              // dot(normal, k1)
    edf: float3,             // edf
    pdf: float              // pdf (non-projected hemisphere)
}

struct VDF_sample_data{}

struct VDF_pdf_data{}

struct VDF_evaluate_data{}

type bsdf = fn(material_geometry) -> executable_bsdf;
type edf = fn(material_geometry) -> executable_edf;
type vdf = fn(material_geometry) -> executable_vdf;

struct executable_bsdf{
    sample: fn(&mut BSDF_sample_data, State) -> (),
    pdf: fn(&mut BSDF_pdf_data, State) -> (),
    evaluate: fn(&mut BSDF_evaluate_data, State) -> (),
    is_default: bool
}


struct executable_edf{
    sample: fn(&mut EDF_sample_data, State) -> (),
    pdf: fn(&mut EDF_pdf_data, State) -> (),
    evaluate: fn(&mut EDF_evaluate_data, State) -> (),
    is_default: bool
}

struct executable_vdf{
    sample: fn(&mut VDF_sample_data, State) -> (),
    pdf: fn(&mut VDF_pdf_data, State) -> (),
    evaluate: fn(&mut VDF_evaluate_data, State) -> (),
    is_default: bool
}

fn @bsdf__mdl_math(math: mdl_math) -> bsdf
{
    |geo:material_geometry|{
    executable_bsdf{
        sample: |data:&mut BSDF_sample_data, state:State|{
            absorb_sample(data);
        },
        pdf: |data:&mut BSDF_pdf_data, state:State|{
            absorb_pdf(data);
        },
        evaluate: |data:&mut BSDF_evaluate_data, state:State|{
            absorb_evaluate(data);
        },
        is_default: true
    }
    }
}

fn @vdf__mdl_math(math: mdl_math) -> vdf
{
    |geo:material_geometry|{
    executable_vdf{
        sample: |data:&mut VDF_sample_data, state:State|{
            
        },
        pdf: |data:&mut VDF_pdf_data, state:State|{
            
        },
        evaluate: |data:&mut VDF_evaluate_data, state:State|{
            
        },
        is_default: true
    }
    }
}

fn @edf__mdl_math(math: mdl_math) -> edf
{
    |geo:material_geometry|{
    executable_edf{
        sample: |data:&mut EDF_sample_data, state:State|{
            no_emission_sample(data)
        },
        pdf: |data:&mut EDF_pdf_data, state:State|{
            no_emission_pdf(data)
        },
        evaluate: |data:&mut EDF_evaluate_data, state:State|{
            no_emission_evaluate(data)
        },
        is_default: true
    }
    }
}