/******************************************************************************
 * Copyright (c) 2017-2020, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

/*! \page mi_neuray_example_execution_ptx Example for Execution of Compiled MDL Materials (PTX)

<div align="right">
    [\link mi_neuray_example_execution_native Previous\endlink]
    [\link mi_neuray_examples Up\endlink]
\if MDL_BIN_RELEASE
    [\link mi_neuray_example_execution_glsl Next\endlink]
\else
    [\link mi_neuray_example_df_cuda Next\endlink]
\endif
</div>

This example describes the API of the code generated by the "PTX" backend for compiled materials
and shows how a renderer can call this generated code to evaluate sub-expressions of multiple
materials using CUDA.

\section example_execution_ptx_new New Topics

  - MDL material state (PTX)
  - Execution of generated code (PTX)
  - Loading textures (PTX)
  - Texture access functions (PTX)

\section example_execution_ptx_descr Detailed Description

<dl>
<dt><b>MDL material state (PTX)</b></dt>
<dd><br>
The MDL material state structure #mi::neuraylib::Shading_state_material is a representation
of the renderer state as defined in section 19 "Renderer state" in the MDL
specification. It is used to make the state of the renderer (like the position of an
intersection point on the surface, the shading normal and the texture coordinates)
available to the generated code.

Here's a version of the material state structure making use of the types from
CUDA's \c vector_types.h:

\code
    struct Shading_state_material {
        float3                 normal;                  // state::normal() result
        float3                 geom_normal;             // state::geom_normal() result
        float3                 position;                // state::position() result
        float                  animation_time;          // state::animation_time() result
        const float3          *text_coords;             // state::texture_coordinate() table
        const float3          *tangent_u;               // state::texture_tangent_u() table
        const float3          *tangent_v;               // state::texture_tangent_v() table
        float4                *text_results;            // texture results lookup table
        const char            *ro_data_segment;         // read-only data segment
        const float4          *world_to_object;         // world-to-object transform matrix
        const float4          *object_to_world;         // object-to-world transform matrix
        int                    object_id;               // state::object_id() result
    };
\endcode

Please refer to the structure documentation for more information.

In this example, we fill the material state structure with some example values and only use
one texture space.
For the world-to-object and object-to-world transformation matrices we use identity matrices.
We will iterate the \c position and \c text_coords fields over a 2x2 quad around the
center of the world with position \c x and \c y coordinates ranging from -1 to 1 and the
texture uv-coordinates ranging from 0 to 1, respectively.
</dd>

<dt><b>Execution of generated code (PTX)</b></dt>
<dd><br>
For the non-native backends, the generated code has to be called directly from the
corresponding framework, so we need to know the prototypes of the functions generated
via #mi::neuraylib::IMdl_backend::translate_material_expression().
With \c "NAME" being the function name you provided as \c fname parameter and \c "T"
being the result type, they look like this:

\code
    void NAME(
        T                             *result,
        Shading_state_material const  *state,
        Resource_data const           *res_data,
        void const                    *exception_state,
        char const                    *captured_args);
\endcode

or written as a PTX prototype:

\code
.visible .func NAME(
        .param .b64 result,
        .param .b64 state,
        .param .b64 res_data,
        .param .b64 exception_state,
        .param .b64 captured_args
);
\endcode

The \c res_data parameter is used to provide access to resources like textures
depending on the way how those resources are accessed (see "Texture access functions" below).
If it is not used, the pointers inside the structure may be NULL:

\code
    struct Resource_data {
        const void                 *shared_data;
        const Texture_handler_base *texture_handler;
    };
\endcode

The \c exception_state parameter allows to provide handlers for out-of-bounds
array access exceptions and division-by-zero exceptions. But for the PTX backend, this is not
supported and the parameter should be set to NULL.

The \c captured_args parameter is used to provide the data of the
#mi::neuraylib::ITarget_argument_block object for class-compiled materials.
The data can either be manually created using the information from
#mi::neuraylib::ITarget_value_layout or by using
#mi::neuraylib::ITarget_code::get_argument_block() or
#mi::neuraylib::ITarget_code::create_argument_block().
For instance-compiled materials, this parameter should be set to NULL.
See \ref mi_neuray_compilation_modes for more details about instance and class compilation.

To make the generated functions available to our CUDA kernel, we have to link them with
the kernel.
We could just declare the generated functions with the corresponding names as <tt>extern "C"</tt>
in the CUDA source code of the kernel, but we may want to decide at runtime how many
materials will be available.
So we will add an indirection through an array of pointers to the generated functions
which we provide as an additional PTX source code buffer to the CUDA linker.

\note We currently have to add a dummy function to the PTX code containing this function
pointer array, because the CUDA linker will otherwise just resolve the function addresses to zero.

\note Also, we need to compile the CUDA kernel with the option \c -rdc=true (relocatable device
code), otherwise the \c extern declared function array will be treated as a definition resulting
in two arrays.

In this example, we bake multiple materials into a texture with a user-configurable checkerboard
pattern by executing a material for every texel updating the material state accordingly.
At the end, we write the texture to disk.
</dd>

<dt><b>Loading textures (PTX)</b></dt>
<dd><br>
When the \c nv_freeimage plugin has been loaded via
#mi::neuraylib::IPlugin_configuration::load_plugin_library() before starting the MDL SDK, the SDK will
automatically load textures on the host side for many common image formats and make them
available via #mi::neuraylib::ITarget_code::get_texture().
Note, that the first texture is always the invalid texture, so only if there is more than
just one texture according to #mi::neuraylib::ITarget_code::get_texture_count(), there will
be real referenced textures available.

Here's a small code snippet showing how to access the #mi::neuraylib::ICanvas of the
texture at index \c i.
\code
    mi::base::Handle<const mi::neuraylib::ITexture> texture(
        transaction->access<mi::neuraylib::ITexture>(target_code->get_texture(i)));
    mi::base::Handle<const mi::neuraylib::IImage> image(
        transaction->access<mi::neuraylib::IImage>(texture->get_image()));
    mi::base::Handle<const mi::neuraylib::ICanvas> canvas(image->get_canvas());
\endcode

The textures still have to be copied to the GPU and possibly they have to be gamma corrected
and converted to a format understood by the texture access functions you provide.
In this example, we use the #mi::neuraylib::IImage_api to apply the gamma correction and to
convert the image format to a float32 RGBA format.

Depending on the texture shape returned by #mi::neuraylib::ITarget_code::get_texture_shape()
the texture image data has to be copied to a CUDA array (2D textures), a 3D array (3D textures)
or a 3D array with the \c cudaArrayCubemap flag set (cube textures). The textures could then be
made available via CUDA texture objects.

\note For cube textures, you should use the \c cudaAddressModeClamp address mode for the
texture objects to avoid visual artifacts in the corners.
</dd>

<dt><b>Texture access functions (PTX)</b></dt>
<dd><br>
For non-native backends, the generated code requires a set of methods implementing texture
access functionality:

- tex_lookup_float4_2d

- tex_lookup_float3_2d

- tex_texel_float4_2d

- tex_lookup_float4_3d

- tex_lookup_float3_3d

- tex_texel_float4_3d

- tex_lookup_float4_cube

- tex_lookup_float3_cube

- tex_resolution_2d

Except for the last one, these correspond directly to the functions described in section 20.3 "Standard library functions - Texture" in the MDL specification.

The \c tex_lookup_* functions receive floating-point texture coordinates and should provide
a sampled value, whereas \c tex_texel_* functions receive integer texture coordinates and
should provide a raw texture value. There are variants for texture lookups with and without
alpha channel (float4 / float3) and for the different texture shapes (2d / 3d / cube) as
described in section 6.12 "Variables and data types - Textures" in the MDL specification.
Note, that PTEX textures are currently not supported by the backends.

\c tex_resolution_2d retrieves the width and height at the given uv-tile coordinates for a texture_2d.
For non-uv-tile textures, the uv-tile coordinates are always (0, 0).

For the PTX backend, there are different ways how the methods can be provided, which can
be chosen by setting the \c "tex_lookup_call_mode" option via the
#mi::neuraylib::IMdl_backend::set_option() method to the corresponding mode.
Please refer to \ref mi_neuray_ptx_texture_lookup_call_modes for more details.

In this example, you can switch from the \c "direct_call" mode to the slower \c "vtable" mode by commenting out this line in \c example_cuda_shared.h:

\code
    check_success(be_cuda_ptx->set_option("tex_lookup_call_mode", "direct_call") == 0);
\endcode
</dd>
</dl>

\section example_execution_ptx Example Source

To compile the source code, you need to install the "CUDA Toolkit 9" available at
<a href="https://developer.nvidia.com/cuda-downloads"
>https://developer.nvidia.com/cuda-downloads</a>.

For Windows, you should install the toolkit with enabled Visual Studio integration to be
able to use the provided project files.

For Linux and Mac OS X, you have to provide the path to the CUDA Toolkit installation via a
\c "CUDA_PATH" environment variable or by setting the path in the \c Makefile.

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/execution_cuda/example_execution_cuda.cpp</tt>

\include execution_cuda/example_execution_cuda.cpp

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/shared/texture_support_cuda.h</tt>

  \include shared/texture_support_cuda.h

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/shared/example_cuda_shared.h</tt>

\include shared/example_cuda_shared.h

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/execution_cuda/example_execution_cuda.cu</tt>

\include execution_cuda/example_execution_cuda.cu

<div align="right">
    [\link mi_neuray_example_execution_native Previous\endlink]
    [\link mi_neuray_examples Up\endlink]
\if MDL_BIN_RELEASE
    [\link mi_neuray_example_execution_glsl Next\endlink]
\else
    [\link mi_neuray_example_df_cuda Next\endlink]
\endif
</div>

*/
