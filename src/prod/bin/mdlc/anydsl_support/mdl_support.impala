struct float4 {
    x: float,
    y: float,
    z: float,
    w: float
}

struct float3 {
    x: float,
    y: float,
    z: float
}

struct float2 {
    x: float,
    y: float
}

struct double4 {
     x: double,
     y: double,
     z: double,
     w: double
 }

 struct double3 {
     x: double,
     y: double,
     z: double
 }

 struct double2 {
     x: double,
     y: double
 }

struct bool4 {
    x: bool,
    y: bool,
    z: bool,
    w: bool
}

struct bool3 {
    x: bool,
    y: bool,
    z: bool
}

struct bool2 {
    x: bool,
    y: bool
}

struct int4 {
    x: int,
    y: int,
    z: int,
    w: int
}

struct int3 {
    x: int,
    y: int,
    z: int
}

struct int2 {
    x: int,
    y: int
}


struct float2x2{
    x: float2,
    y: float2
}


struct float3x2{
    x: float2,
    y: float2,
    z: float2
}

struct float4x2{
    x: float2,
    y: float2,
    z: float2,
    w: float2
}

struct float2x3{
    x: float3,
    y: float3
}


struct float3x3{
    x: float3,
    y: float3,
    z: float3
}

struct float4x3{
    x: float3,
    y: float3,
    z: float3,
    w: float3
}

struct float2x4{
    x: float4,
    y: float4
}


struct float3x4{
    x: float4,
    y: float4,
    z: float4
}

struct float4x4{
    x: float4,
    y: float4,
    z: float4,
    w: float4
}


struct double2x2{
    x: double2,
    y: double2
}


struct double3x2{
    x: double2,
    y: double2,
    z: double2
}

struct double4x2{
    x: double2,
    y: double2,
    z: double2,
    w: double2
}

struct double2x3{
    x: double3,
    y: double3
}


struct double3x3{
    x: double3,
    y: double3,
    z: double3
}

struct double4x3{
    x: double3,
    y: double3,
    z: double3,
    w: double3
}

struct double2x4{
    x: double4,
    y: double4
}


struct double3x4{
    x: double4,
    y: double4,
    z: double4
}

struct double4x4{
    x: double4,
    y: double4,
    z: double4,
    w: double4
}

fn @float2_get(a: float2, b: int) -> float{
    match(b){
        0 => a.x,
        1 => a.y,
        _ => 0.0f
    }
}

fn @float3_get(a: float3, b: int) -> float{
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        _ => 0.0f
    }
}

fn @float4_get(a: float4, b: int) -> float{
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        3 => a.w,
        _ => 0.0f
    }
}

fn @double2_get(a: double2, b: int) -> double{
    match(b){
        0 => a.x,
        1 => a.y,
        _ => 0.0
    }
}

fn @double3_get(a: double3, b: int) -> double{
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        _ => 0.0
    }
}

fn @double4_get(a: double4, b: int) -> double{
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        3 => a.w,
        _ => 0.0
    }
}

fn @int2_get(a: int2, b: int) -> int{
    match(b){
        0 => a.x,
        1 => a.y,
        _ => 0
    }
}

fn @int3_get(a: int3, b: int) -> int{
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        _ => 0
    }
}

fn @int4_get(a: int4, b: int) -> int{
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        3 => a.w,
        _ => 0
    }
}

fn @bool2_get(a: bool2, b: int) -> bool{
    match(b){
        0 => a.x,
        1 => a.y,
        _ => false
    }
}

fn @bool3_get(a: bool3, b: int) -> bool{
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        _ => false
    }
}

fn @bool4_get(a: bool4, b: int) -> bool{
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        3 => a.w,
        _ => false
    }
}

fn @float2x2_get(a: float2x2, b: int) -> float2 {
    match(b){
        0 => a.x,
        1 => a.y,
        _ => float2{x: 0.0f, y: 0.0f}
    }
}

fn @float3x2_get(a: float3x2, b: int) -> float2 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        _ => float2{x: 0.0f, y: 0.0f}
    }
}

fn @float4x2_get(a: float4x2, b: int) -> float2 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        3 => a.w,
        _ => float2{x: 0.0f, y: 0.0f}
    }
}

fn @float2x3_get(a: float2x3, b: int) -> float3 {
    match(b){
        0 => a.x,
        1 => a.y,
        _ => float3{x: 0.0f, y: 0.0f, z: 0.0f}
    }
}

fn @float3x3_get(a: float3x3, b: int) -> float3 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        _ => float3{x: 0.0f, y: 0.0f, z: 0.0f}
    }
}

fn @float4x3_get(a: float4x3, b: int) -> float3 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        3 => a.w,
        _ => float3{x: 0.0f, y: 0.0f, z: 0.0f}
    }
}


fn @float2x4_get(a: float2x4, b: int) -> float4 {
    match(b){
        0 => a.x,
        1 => a.y,
        _ => float4{x: 0.0f, y: 0.0f, z: 0.0f, w: 0.0f}
    }
}

fn @float3x4_get(a: float3x4, b: int) -> float4 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        _ => float4{x: 0.0f, y: 0.0f, z: 0.0f, w: 0.0f}
    }
}

fn @float4x4_get(a: float4x4, b: int) -> float4 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        3 => a.w,
        _ => float4{x: 0.0f, y: 0.0f, z: 0.0f, w: 0.0f}
    }
}


fn @double2x2_get(a: double2x2, b: int) -> double2 {
    match(b){
        0 => a.x,
        1 => a.y,
        _ => double2{x: 0.0, y: 0.0}
    }
}

fn @double3x2_get(a: double3x2, b: int) -> double2 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        _ => double2{x: 0.0, y: 0.0}
    }
}

fn @double4x2_get(a: double4x2, b: int) -> double2 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        3 => a.w,
        _ => double2{x: 0.0, y: 0.0}
    }
}

fn @double2x3_get(a: double2x3, b: int) -> double3 {
    match(b){
        0 => a.x,
        1 => a.y,
        _ => double3{x: 0.0, y: 0.0, z: 0.0}
    }
}

fn @double3x3_get(a: double3x3, b: int) -> double3 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        _ => double3{x: 0.0, y: 0.0, z: 0.0}
    }
}

fn @double4x3_get(a: double4x3, b: int) -> double3 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        3 => a.w,
        _ => double3{x: 0.0, y: 0.0, z: 0.0}
    }
}


fn @double2x4_get(a: double2x4, b: int) -> double4 {
    match(b){
        0 => a.x,
        1 => a.y,
        _ => double4{x: 0.0, y: 0.0, z: 0.0, w: 0.0}
    }
}

fn @double3x4_get(a: double3x4, b: int) -> double4 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        _ => double4{x: 0.0, y: 0.0, z: 0.0, w: 0.0}
    }
}

fn @double4x4_get(a: double4x4, b: int) -> double4 {
    match(b){
        0 => a.x,
        1 => a.y,
        2 => a.z,
        3 => a.w,
        _ => double4{x: 0.0, y: 0.0, z: 0.0, w: 0.0}
    }
}



struct color {
    r: float,
    g: float,
    b: float
}

fn @color_get(a: color, b: int) -> float{
    match(b){
        0 => a.r,
        1 => a.g,
        2 => a.b,
        _ => 0.0f
    }
}

fn @float3__float(a: float) -> float3{
    float3{
        x: a,
        y: a,
        z: a
    }
}

fn @float3x3__float(a: float) -> float3x3{
    float3x3{
        x: float3__float(a),
        y: float3__float(a),
        z: float3__float(a),
    }
}

fn @float4__float(a: float) -> float4{
    float4{
        x: a,
        y: a,
        z: a,
        w: a,
    }
}

fn @float4x4__float(a: float) -> float4x4{
    float4x4{
        x: float4__float(a),
        y: float4__float(a),
        z: float4__float(a),
        w: float4__float(a),
    }
}


struct material {
    thin_walled: bool,
    surface: material_surface,
    backface: material_surface,
    ior: fn(State) -> color,
    volume: material_volume,
    geometry: material_geometry,
}

struct material_parameters{
    thin_walled: bool,
    ior: color
}

fn @sample_material_bsdf(mat: material, data: &mut BSDF_sample_data, state: State, math: mdl_math) -> (){
    let pos = mat.geometry.displacement(state);
    let normal = mat.geometry.normal(state);
    let surface = if(mat.backface.scattering.is_default || !mat.thin_walled || math.dot__float3_float3(data.k1, state.normal()) >= 0.0f) {mat.surface} else {mat.backface};
    let params = material_parameters{
        thin_walled: mat.thin_walled,
        ior: mat.ior(state)
    };
    let adj_state = adjust_state(state, pos, normal);
    surface.scattering.sample(data, adj_state, params);
}

fn @evaluate_material_bsdf(mat: material, data: &mut BSDF_evaluate_data, state: State, math: mdl_math) -> (){
    let pos = mat.geometry.displacement(state);
    let normal = mat.geometry.normal(state);
    let surface = if(mat.backface.scattering.is_default || !mat.thin_walled || math.dot__float3_float3(data.k1, state.normal()) >= 0.0f) {mat.surface} else {mat.backface};
    let params = material_parameters{
        thin_walled: mat.thin_walled,
        ior: mat.ior(state)
    };
    let adj_state = adjust_state(state, pos, normal);
    surface.scattering.evaluate(data, adj_state, params);
}

fn @pdf_material_bsdf(mat: material, data: &mut BSDF_pdf_data, state: State, math: mdl_math) -> (){
    let pos = mat.geometry.displacement(state);
    let normal = mat.geometry.normal(state);
    let surface = if(mat.backface.scattering.is_default || !mat.thin_walled || math.dot__float3_float3(data.k1, state.normal()) >= 0.0f) {mat.surface} else {mat.backface};
    let params = material_parameters{
        thin_walled: mat.thin_walled,
        ior: mat.ior(state)
    };
    let adj_state = adjust_state(state, pos, normal);
    surface.scattering.pdf(data, adj_state, params);
}

fn @sample_material_edf(mat: material, data: &mut EDF_sample_data, state: State, math: mdl_math) -> (){
    let pos = mat.geometry.displacement(state);
    let normal = mat.geometry.normal(state);
    let surface = if(mat.backface.scattering.is_default || !mat.thin_walled || math.dot__float3_float3(data.k1, state.normal()) >= 0.0f) {mat.surface} else {mat.backface};
    let params = material_parameters{
        thin_walled: mat.thin_walled,
        ior: mat.ior(state)
    };
    let adj_state = adjust_state(state, pos, normal);
    surface.emission.emission.sample(data, adj_state, params);
}

fn @evaluate_material_edf(mat: material, data: &mut EDF_evaluate_data, state: State, math: mdl_math) -> (){
    let pos = mat.geometry.displacement(state);
    let normal = mat.geometry.normal(state);
    let surface = if(mat.backface.scattering.is_default || !mat.thin_walled || math.dot__float3_float3(data.k1, state.normal()) >= 0.0f) {mat.surface} else {mat.backface};
    let params = material_parameters{
        thin_walled: mat.thin_walled,
        ior: mat.ior(state)
    };
        let adj_state = adjust_state(state, pos, normal);

    surface.emission.emission.evaluate(data, adj_state, params);
}

fn @pdf_material_edf(mat: material, data: &mut EDF_pdf_data, state: State, math: mdl_math) -> (){
    let pos = mat.geometry.displacement(state);
    let normal = mat.geometry.normal(state);
    let surface = if(mat.backface.scattering.is_default || !mat.thin_walled || math.dot__float3_float3(data.k1, state.normal()) >= 0.0f) {mat.surface} else {mat.backface};
    let params = material_parameters{
        thin_walled: mat.thin_walled,
        ior: mat.ior(state)
    };
        let adj_state = adjust_state(state, pos, normal);

    surface.emission.emission.pdf(data, adj_state, params);
}

fn @sample_material_vdf(mat: material, data: &mut VDF_sample_data, state: State, math: mdl_math) -> (){
    let pos = mat.geometry.displacement(state);
    let normal = mat.geometry.normal(state);
    let params = material_parameters{
        thin_walled: mat.thin_walled,
        ior: mat.ior(state)
    };
        let adj_state = adjust_state(state, pos, normal);

    mat.volume.scattering.sample(data, adj_state, params);
}

fn @evaluate_material_vdf(mat: material, data: &mut VDF_evaluate_data, state: State, math: mdl_math) -> (){
    let pos = mat.geometry.displacement(state);
    let normal = mat.geometry.normal(state);
    let params = material_parameters{
        thin_walled: mat.thin_walled,
        ior: mat.ior(state)
    };
        let adj_state = adjust_state(state, pos, normal);

    mat.volume.scattering.evaluate(data, adj_state, params);
}

fn @pdf_material_vdf(mat: material, data: &mut VDF_pdf_data, state: State, math: mdl_math) -> (){
    let pos = mat.geometry.displacement(state);
    let normal = mat.geometry.normal(state);
    let params = material_parameters{
        thin_walled: mat.thin_walled,
        ior: mat.ior(state)
    };
        let adj_state = adjust_state(state, pos, normal);

    mat.volume.scattering.pdf(data, adj_state, params);
}




fn @material__bool_material_surface_material_surface_color_material_volume_material_geometry_mdl_math(
    thin_walled: fn(State) -> bool,
    surface: fn(State) -> material_surface,
    backface: fn(State) -> material_surface,
    ior: fn(State) -> color,
    volume: fn(State) -> material_volume,
    geometry: fn(State) -> material_geometry,
    math: mdl_math
) -> material {
    
    material{
        thin_walled: thin_walled(dummy_state),
        surface: surface(dummy_state),
        backface: backface(dummy_state),
        ior: ior,
        volume: volume(dummy_state),
        geometry: geometry(dummy_state),
    }
}

fn @material__material(copy: fn(State) -> material) -> material{
    copy(dummy_state)
}



struct material_surface {
    scattering: bsdf,
    emission: material_emission,
};

fn @material_surface__bsdf_material_emission_mdl_math(
    scattering: fn(State) -> bsdf,
    emission: fn(State) -> material_emission,
    math: mdl_math
) -> material_surface{
    
        material_surface{
            scattering: scattering(dummy_state),
            emission: emission(dummy_state)
        }
    
}


fn @material_surface__material_surface(copy: fn(State) -> material_surface) -> material_surface{
    copy(dummy_state)
}



struct material_emission {
    emission: edf,
    intensity: fn(State) -> color,
    mode: intensity_mode
};
fn @material_emission__edf_color_intensity_mode_mdl_math(
    emission: fn(State) -> edf, 
    intensity: fn(State) -> color, 
    mode: fn(State) -> intensity_mode,
    math: mdl_math
) -> material_emission{
    
        material_emission{
            emission: emission(dummy_state),
            intensity: intensity,
            mode: mode(dummy_state)
        }
    
}

enum intensity_mode {
    intensity_radiant_exitance,
    intensity_power
}



struct material_volume {
    scattering: vdf,
    absorption_coefficient: fn(State) -> color,
    scattering_coefficient: fn(State) -> color
}

fn @material_volume__vdf_color_color_mdl_math(
    scattering: fn(State) -> vdf,
    absorption_coefficient: fn(State) -> color,
    scattering_coefficient: fn(State) -> color,
    math: mdl_math
) -> material_volume 
{
    
        material_volume{
            scattering: scattering(dummy_state),
            absorption_coefficient: absorption_coefficient,
            scattering_coefficient: scattering_coefficient
        }
    
}

struct material_geometry {
    displacement: fn(State) -> float3,
    cutout_opacity: fn(State) -> float,
    normal: fn(State) -> float3
}

fn @material_geometry__float3_float_float3_mdl_math(
    displacement: fn(State) -> float3,
    cutout_opacity: fn(State) -> float,
    normal: fn(State) -> float3,
    math: mdl_math
) -> material_geometry
{
    material_geometry{
        displacement: displacement,
        cutout_opacity: cutout_opacity,
        normal: normal
    }
}



    static BSDF_EVENT_DIFFUSE      = 1;
    static BSDF_EVENT_GLOSSY       = 1 << 1;
    static BSDF_EVENT_SPECULAR	    = 1 << 2;
    static BSDF_EVENT_REFLECTION   = 1 << 3;
    static BSDF_EVENT_TRANSMISSION = 1 << 4;



    static BSDF_EVENT_ABSORB = 0;
    static BSDF_EVENT_DIFFUSE_REFLECTION    = BSDF_EVENT_DIFFUSE  | BSDF_EVENT_REFLECTION;
    static BSDF_EVENT_DIFFUSE_TRANSMISSION  = BSDF_EVENT_DIFFUSE  | BSDF_EVENT_TRANSMISSION;
    static BSDF_EVENT_GLOSSY_REFLECTION     = BSDF_EVENT_GLOSSY   | BSDF_EVENT_REFLECTION;
    static BSDF_EVENT_GLOSSY_TRANSMISSION   = BSDF_EVENT_GLOSSY   | BSDF_EVENT_TRANSMISSION;
    static BSDF_EVENT_SPECULAR_REFLECTION   = BSDF_EVENT_SPECULAR | BSDF_EVENT_REFLECTION;
    static BSDF_EVENT_SPECULAR_TRANSMISSION = BSDF_EVENT_SPECULAR | BSDF_EVENT_TRANSMISSION;

   




static BSDF_USE_MATERIAL_IOR: float = -1.0f;

struct BSDF_sample_data
{
    // Input fields
    ior1: float3, // IOR current medium
    ior2: float3, // IOR other side
    k1: float3,  // outgoing direction
    xi: float3,  // pseudo-random sample number

    // Output fields
    k2: float3,            // incoming direction
    pdf: float,           // pdf (non-projected hemisphere)
    bsdf_over_pdf: float3, // bsdf * dot(normal, k2) / pdf
    event_type: int       // BSDF_event_type
}

struct BSDF_pdf_data
{
    // Input fields
    ior1: float3,
    ior2: float3,
    k1: float3,
    k2: float3,

    // Output fields
    pdf: float,
}

struct BSDF_evaluate_data
{
    // Input fields
    ior1: float3,
    ior2: float3,
    k1: float3,
    k2: float3,

    // Output fields
    bsdf: float3,
    pdf: float,
}

fn @make_bsdf_evaluate_data(
    ior1: float3,
    ior2: float3,
    k1: float3,
    k2: float3
) -> BSDF_evaluate_data
{
    BSDF_evaluate_data{
        ior1: ior1,
        ior2: ior2,
        k1: k1,
        k2: k2,
        bsdf: make_float3(0.0f,0.0f,0.0f),
        pdf: 0.0f
    }
}


    static EDF_EVENT_NONE = 0;
    static EDF_EVENT_EMISSION = 1;


struct EDF_sample_data
{
    // Input fields
    xi: float3,              // pseudo-random sample number

    // Output fields
    k1: float3,              // outgoing direction
    pdf: float,              // pdf (non-projected hemisphere)
    edf_over_pdf: float3,    // edf * dot(normal,k1) / pdf
    event_type: int
}

struct EDF_pdf_data
{
    // Input fields
    k1: float3,              // outgoing direction

    // Output fields
    pdf: float              // pdf (non-projected hemisphere)
}

struct EDF_evaluate_data
{
    // Input fields
    k1: float3,              // outgoing direction

    // Output fields
    cos: float,              // dot(normal, k1)
    edf: float3,             // edf
    pdf: float              // pdf (non-projected hemisphere)
}



struct VDF_sample_data{}

struct VDF_pdf_data{}

struct VDF_evaluate_data{}



struct bsdf{
    sample: fn(&mut BSDF_sample_data, State, material_parameters) -> (),
    pdf: fn(&mut BSDF_pdf_data, State, material_parameters) -> (),
    evaluate: fn(&mut BSDF_evaluate_data, State, material_parameters) -> (),
    is_default: bool
}


struct edf{
    sample: fn(&mut EDF_sample_data, State, material_parameters) -> (),
    pdf: fn(&mut EDF_pdf_data, State, material_parameters) -> (),
    evaluate: fn(&mut EDF_evaluate_data, State, material_parameters) -> (),
    is_default: bool
}

struct vdf{
    sample: fn(&mut VDF_sample_data, State, material_parameters) -> (),
    pdf: fn(&mut VDF_pdf_data, State, material_parameters) -> (),
    evaluate: fn(&mut VDF_evaluate_data, State, material_parameters) -> (),
    is_default: bool
}

fn @bsdf__mdl_math(math: mdl_math) -> bsdf
{
    
    bsdf{
        sample: @|data:&mut BSDF_sample_data, state:State, params: material_parameters|{
            absorb_sample(data);
        },
        pdf: @|data:&mut BSDF_pdf_data, state:State, params: material_parameters|{
            absorb_pdf(data);
        },
        evaluate: @|data:&mut BSDF_evaluate_data, state:State,params: material_parameters|{
            absorb_evaluate(data);
        },
        is_default: true
    }
    
}

fn @bsdf__bsdf_mdl_math(b: fn(State) -> bsdf, math: mdl_math) -> bsdf{
    b(dummy_state)
}

fn @vdf__mdl_math(math: mdl_math) -> vdf
{
    
    vdf{
        sample: @|data:&mut VDF_sample_data, state:State, params: material_parameters|{
            
        },
        pdf: @|data:&mut VDF_pdf_data, state:State, params: material_parameters|{
            
        },
        evaluate: @|data:&mut VDF_evaluate_data, state:State, params: material_parameters|{
            
        },
        is_default: true
    }
    
}

fn vdf__vdf_mdl_math(v: fn(State) -> vdf, math: mdl_math) -> vdf{
    v(dummy_state)
}

fn @edf__edf_mdl_math(e: fn(State) -> edf, math: mdl_math) -> edf{
    e(dummy_state)
}

fn @edf__mdl_math(math: mdl_math) -> edf
{
    
    edf{
        sample: @|data:&mut EDF_sample_data, state:State, params: material_parameters|{
            no_emission_sample(data)
        },
        pdf: @|data:&mut EDF_pdf_data, state:State, params: material_parameters|{
            no_emission_pdf(data)
        },
        evaluate: @|data:&mut EDF_evaluate_data, state:State, params: material_parameters|{
            no_emission_evaluate(data)
        },
        is_default: true
    }
    
}