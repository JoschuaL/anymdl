extern "C" {
    fn "anydsl_info" runtime_info() -> ();

    fn "anydsl_alloc"          runtime_alloc(i32, i64) -> &[i8];
    fn "anydsl_alloc_host"     runtime_alloc_host(i32, i64) -> &[i8];
    fn "anydsl_alloc_unified"  runtime_alloc_unified(i32, i64) -> &[i8];
    fn "anydsl_copy"           runtime_copy(i32, &[i8], i64, i32, &[i8], i64, i64) -> ();
    fn "anydsl_get_device_ptr" runtime_get_device_ptr(i32, &[i8]) -> &[i8];
    fn "anydsl_release"        runtime_release(i32, &[i8]) -> ();
    fn "anydsl_release_host"   runtime_release_host(i32, &[i8]) -> ();
    fn "anydsl_synchronize"    runtime_synchronize(i32) -> ();

    fn "anydsl_random_seed"     random_seed(u32) -> ();
    fn "anydsl_random_val_f32"  random_val_f32() -> f32;
    fn "anydsl_random_val_u64"  random_val_u64() -> u64;

    fn "anydsl_get_micro_time"  get_micro_time() -> i64;
    fn "anydsl_get_kernel_time" get_kernel_time() -> i64;

    fn "anydsl_print_i16"    print_i16(i16) -> ();
    fn "anydsl_print_i32"    print_i32(i32) -> ();
    fn "anydsl_print_i64"    print_i64(i64) -> ();
    fn "anydsl_print_f32"    print_f32(f32) -> ();
    fn "anydsl_print_f64"    print_f64(f64) -> ();
    fn "anydsl_print_char"   print_char(u8) -> ();
    fn "anydsl_print_string" print_string(&[u8]) -> ();
    fn "anydsl_print_flush"  print_flush() -> ();
}

struct Buffer {
    data : &[i8],
    size : i64,
    device : i32
}

fn @alloc(dev: i32, size: i32) -> Buffer {
    Buffer {
        device : dev,
        data : runtime_alloc(dev, size as i64),
        size : size as i64
    }
}
fn @alloc_host(dev: i32, size: i32) -> Buffer {
    Buffer {
        device : dev,
        data : runtime_alloc_host(dev, size as i64),
        size : size as i64
    }
}
fn @alloc_unified(dev: i32, size: i32) -> Buffer {
    Buffer {
        device : dev,
        data : runtime_alloc_unified(dev, size as i64),
        size : size as i64
    }
}
fn @release(buf: Buffer) -> () { runtime_release(buf.device, buf.data) }

fn @runtime_device(platform: i32, device: i32) -> i32 { platform | (device << 4) }

fn @alloc_cpu(size: i32) -> Buffer { alloc(0, size) }
fn @alloc_cuda(dev: i32, size: i32) -> Buffer { alloc(runtime_device(1, dev), size) }
fn @alloc_cuda_host(dev: i32, size: i32) -> Buffer { alloc_host(runtime_device(1, dev), size) }
fn @alloc_cuda_unified(dev: i32, size: i32) -> Buffer { alloc_unified(runtime_device(1, dev), size) }
fn @synchronize_cuda(dev: i32) -> () { runtime_synchronize(runtime_device(1, dev)) }
fn @alloc_opencl(dev: i32, size: i32) -> Buffer { alloc(runtime_device(2, dev), size) }
fn @alloc_opencl_unified(dev: i32, size: i32) -> Buffer { alloc_unified(runtime_device(2, dev), size) }
fn @synchronize_opencl(dev: i32) -> () { runtime_synchronize(runtime_device(2, dev)) }
fn @alloc_hsa(dev: i32, size: i32) -> Buffer { alloc(runtime_device(3, dev), size) }
fn @alloc_hsa_host(dev: i32, size: i32) -> Buffer { alloc_host(runtime_device(3, dev), size) }
fn @alloc_hsa_unified(dev: i32, size: i32) -> Buffer { alloc_unified(runtime_device(3, dev), size) }
fn @synchronize_hsa(dev: i32) -> () { runtime_synchronize(runtime_device(3, dev)) }

fn @copy(src: Buffer, dst: Buffer) -> () {
    runtime_copy(src.device, src.data, 0i64, dst.device, dst.data, 0i64, src.size)
}

fn @copy_offset(src: Buffer, off_src: i32, dst: Buffer, off_dst: i32, size: i32) -> () {
    runtime_copy(src.device, src.data, off_src as i64, dst.device, dst.data, off_dst as i64, size as i64)
}


// range, range_step, unroll, unroll_step, etc.
fn @(?lower & ?upper & ?step) unroll_step(lower: i32, upper: i32, @step: i32, body: fn(i32) -> ()) -> () {
    if lower < upper {
        @@body(lower);
        unroll_step(lower+step, upper, step, body)
    }
}

fn @(?upper & ?lower & ?step) unroll_step_rev(upper: i32, lower: i32, @step: i32, body: fn(i32) -> ()) -> () {
    if upper > lower {
        @@body(upper);
        unroll_step_rev(upper-step, lower, step, body)
    }
}

fn @range(lower: i32, upper: i32, body: fn(i32) -> ()) -> () { unroll_step($lower, $upper, 1, body) }
fn @range_step(lower: i32, upper: i32, step: i32, body: fn(i32) -> ()) -> () { unroll_step($lower, $upper, step, body) }
fn @range_rev(upper: i32, lower: i32, body: fn(i32) -> ()) -> () { unroll_step_rev($upper, $lower, 1, body) }

fn @unroll(lower: i32, upper: i32, body: fn(i32) -> ()) -> () { unroll_step(lower, upper, 1, body) }
fn @unroll_rev(upper: i32, lower: i32, body: fn(i32) -> ()) -> () { unroll_step_rev(upper, lower, 1, body) }

struct WorkItem {
    tidx  : fn() -> i32,
    tidy  : fn() -> i32,
    tidz  : fn() -> i32,
    bidx  : fn() -> i32,
    bidy  : fn() -> i32,
    bidz  : fn() -> i32,
    gidx  : fn() -> i32,
    gidy  : fn() -> i32,
    gidz  : fn() -> i32,
    bdimx : fn() -> i32,
    bdimy : fn() -> i32,
    bdimz : fn() -> i32,
    gdimx : fn() -> i32,
    gdimy : fn() -> i32,
    gdimz : fn() -> i32,
    nblkx : fn() -> i32,
    nblky : fn() -> i32,
    nblkz : fn() -> i32
}

struct Accelerator {
    exec          : fn((i32, i32, i32), // grid
                       (i32, i32, i32), // block
                       fn(WorkItem) -> ()) -> (),
    sync          : fn() -> (),
    alloc         : fn(i32) -> Buffer,
    alloc_unified : fn(i32) -> Buffer,
    barrier       : fn() -> ()
}

struct Intrinsics {
    expf      : fn(f32) -> f32,
    exp2f     : fn(f32) -> f32,
    logf      : fn(f32) -> f32,
    log2f     : fn(f32) -> f32,
    powf      : fn(f32, f32) -> f32,
    rsqrtf    : fn(f32) -> f32,
    sqrtf     : fn(f32) -> f32,
    fabsf     : fn(f32) -> f32,
    sinf      : fn(f32) -> f32,
    cosf      : fn(f32) -> f32,
    tanf      : fn(f32) -> f32,
    asinf     : fn(f32) -> f32,
    acosf     : fn(f32) -> f32,
    atanf     : fn(f32) -> f32,
    erff      : fn(f32) -> f32,
    atan2f    : fn(f32, f32) -> f32,
    copysignf : fn(f32, f32) -> f32,
    fmaf      : fn(f32, f32, f32) -> f32,
    fmaxf     : fn(f32, f32) -> f32,
    fminf     : fn(f32, f32) -> f32,
    fmodf     : fn(f32, f32) -> f32,
    floorf    : fn(f32) -> f32,
    isinff    : fn(f32) -> i32,
    isnanf    : fn(f32) -> i32,
    isfinitef : fn(f32) -> i32,
    exp       : fn(f64) -> f64,
    exp2      : fn(f64) -> f64,
    log       : fn(f64) -> f64,
    log2      : fn(f64) -> f64,
    pow       : fn(f64, f64) -> f64,
    rsqrt     : fn(f64) -> f64,
    sqrt      : fn(f64) -> f64,
    fabs      : fn(f64) -> f64,
    sin       : fn(f64) -> f64,
    cos       : fn(f64) -> f64,
    tan       : fn(f64) -> f64,
    asin      : fn(f64) -> f64,
    acos      : fn(f64) -> f64,
    atan      : fn(f64) -> f64,
    erf       : fn(f64) -> f64,
    atan2     : fn(f64, f64) -> f64,
    copysign  : fn(f64, f64) -> f64,
    fma       : fn(f64, f64, f64) -> f64,
    fmax      : fn(f64, f64) -> f64,
    fmin      : fn(f64, f64) -> f64,
    fmod      : fn(f64, f64) -> f64,
    floor     : fn(f64) -> f64,
    isinf     : fn(f64) -> i32,
    isnan     : fn(f64) -> i32,
    isfinite  : fn(f64) -> i32,
    min       : fn(i32, i32) -> i32,
    max       : fn(i32, i32) -> i32,
}

extern "C" {
    //fn "sinf"             cpu_sinf(f32) -> f32;
    //fn "cosf"             cpu_cosf(f32) -> f32;
    fn "tanf"             cpu_tanf(f32) -> f32;
    fn "asinf"            cpu_asinf(f32) -> f32;
    fn "acosf"            cpu_acosf(f32) -> f32;
    fn "atanf"            cpu_atanf(f32) -> f32;
    fn "erff"             cpu_erff(f32) -> f32;
    fn "fmodf"            cpu_fmodf(f32, f32) -> f32;
    fn "atan2f"           cpu_atan2f(f32, f32) -> f32;
    fn "anydsl_isinff"    cpu_isinff(f32) -> i32;
    fn "anydsl_isnanf"    cpu_isnanf(f32) -> i32;
    fn "anydsl_isfinitef" cpu_isfinitef(f32) -> i32;
    //fn "sin"              cpu_sin(f64) -> f64;
    //fn "cos"              cpu_cos(f64) -> f64;
    fn "tan"              cpu_tan(f64) -> f64;
    fn "asin"             cpu_asin(f64) -> f64;
    fn "acos"             cpu_acos(f64) -> f64;
    fn "atan"             cpu_atan(f64) -> f64;
    fn "erf"              cpu_erf(f64) -> f64;
    fn "fmod"             cpu_fmod(f64, f64) -> f64;
    fn "atan2"            cpu_atan2(f64, f64) -> f64;
    fn "anydsl_isinf"     cpu_isinf(f64) -> i32;
    fn "anydsl_isnan"     cpu_isnan(f64) -> i32;
    fn "anydsl_isfinite"  cpu_isfinite(f64) -> i32;
}

extern "device" {
    fn "llvm.exp.f32"         cpu_expf(f32) -> f32;
    fn "llvm.exp2.f32"        cpu_exp2f(f32) -> f32;
    fn "llvm.log.f32"         cpu_logf(f32) -> f32;
    fn "llvm.log2.f32"        cpu_log2f(f32) -> f32;
    fn "llvm.pow.f32"         cpu_powf(f32, f32) -> f32;
    fn "llvm.sqrt.f32"        cpu_sqrtf(f32) -> f32;
    fn "llvm.fabs.f32"        cpu_fabsf(f32) -> f32;
    fn "llvm.sin.f32"         cpu_sinf(f32) -> f32;
    fn "llvm.cos.f32"         cpu_cosf(f32) -> f32;
    fn "llvm.floor.f32"       cpu_floorf(f32) -> f32;
    fn "llvm.fma.f32"         cpu_fmaf(f32, f32, f32) -> f32;
    fn "llvm.fmuladd.f32"     cpu_madf(f32, f32, f32) -> f32;
    fn "llvm.copysign.f32"    cpu_copysignf(f32, f32) -> f32;
    fn "llvm.minnum.f32"      cpu_fminf(f32, f32) -> f32;
    fn "llvm.maxnum.f32"      cpu_fmaxf(f32, f32) -> f32;
    fn "llvm.exp.f64"         cpu_exp(f64) -> f64;
    fn "llvm.exp2.f64"        cpu_exp2(f64) -> f64;
    fn "llvm.log.f64"         cpu_log(f64) -> f64;
    fn "llvm.log2.f64"        cpu_log2(f64) -> f64;
    fn "llvm.pow.f64"         cpu_pow(f64, f64) -> f64;
    fn "llvm.sqrt.f64"        cpu_sqrt(f64) -> f64;
    fn "llvm.fabs.f64"        cpu_fabs(f64) -> f64;
    fn "llvm.sin.f64"         cpu_sin(f64) -> f64;
    fn "llvm.cos.f64"         cpu_cos(f64) -> f64;
    fn "llvm.floor.f64"       cpu_floor(f64) -> f64;
    fn "llvm.fma.f64"         cpu_fma(f64, f64, f64) -> f64;
    fn "llvm.fmuladd.f64"     cpu_mad(f64, f64, f64) -> f64;
    fn "llvm.copysign.f64"    cpu_copysign(f64, f64) -> f64;
    fn "llvm.minnum.f64"      cpu_fmin(f64, f64) -> f64;
    fn "llvm.maxnum.f64"      cpu_fmax(f64, f64) -> f64;
    fn "llvm.ctpop.i32"       cpu_popcount32(i32) -> i32;
    fn "llvm.ctpop.i64"       cpu_popcount64(i64) -> i64;
    fn "llvm.ctlz.i32"        cpu_clz32(i32, bool) -> i32;
    fn "llvm.ctlz.i64"        cpu_clz64(i64, bool) -> i64;
    fn "llvm.cttz.i32"        cpu_ctz32(i32, bool) -> i32;
    fn "llvm.cttz.i64"        cpu_ctz64(i64, bool) -> i64;
    fn "llvm.x86.bmi.pext.32" cpu_pext32(i32, i32) -> i32;
    fn "llvm.x86.bmi.pext.64" cpu_pext64(i64, i64) -> i64;
    fn "llvm.x86.bmi.pdep.32" cpu_pdep32(i32, i32) -> i32;
    fn "llvm.x86.bmi.pdep.64" cpu_pdep64(i64, i64) -> i64;
    fn "llvm.prefetch"        cpu_prefetch(&u8, i32, i32, i32) -> ();
}



static cpu_intrinsics = Intrinsics {
    expf        : cpu_expf,
    exp2f       : cpu_exp2f,
    logf        : cpu_logf,
    log2f       : cpu_log2f,
    powf        : cpu_powf,
    rsqrtf      : @|a| { 1.0f / cpu_sqrtf(a) },
    sqrtf       : cpu_sqrtf,
    fabsf       : cpu_fabsf,
    sinf        : cpu_sinf,
    cosf        : cpu_cosf,
    tanf        : cpu_tanf,
    asinf       : cpu_asinf,
    acosf       : cpu_acosf,
    atanf       : cpu_atanf,
    erff        : cpu_erff,
    atan2f      : cpu_atan2f,
    copysignf   : cpu_copysignf,
    fmaf        : cpu_fmaf,
    fmaxf       : cpu_fmaxf,
    fminf       : cpu_fminf,
    fmodf       : cpu_fmodf,
    floorf      : cpu_floorf,
    isinff      : cpu_isinff,
    isnanf      : cpu_isnanf,
    isfinitef   : cpu_isfinitef,
    exp         : cpu_exp,
    exp2        : cpu_exp2,
    log         : cpu_log,
    log2        : cpu_log2,
    pow         : cpu_pow,
    rsqrt       : @|a| { 1.0 / cpu_sqrt(a) },
    sqrt        : cpu_sqrt,
    fabs        : cpu_fabs,
    sin         : cpu_sin,
    cos         : cpu_cos,
    tan         : cpu_tan,
    asin        : cpu_asin,
    acos        : cpu_acos,
    atan        : cpu_atan,
    erf         : cpu_erf,
    atan2       : cpu_atan2,
    copysign    : cpu_copysign,
    fma         : cpu_fma,
    fmax        : cpu_fmax,
    fmin        : cpu_fmin,
    fmod        : cpu_fmod,
    floor       : cpu_floor,
    isinf       : cpu_isinf,
    isnan       : cpu_isnan,
    isfinite    : cpu_isfinite,
    min         : @|a, b| { if a < b { a } else { b } },
    max         : @|a, b| { if a > b { a } else { b } },
};
